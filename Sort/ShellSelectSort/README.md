# 希尔排序（Shell Sort）

## 算法概述
希尔排序是插入排序的一种改进版本，它的基本思想是先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录"基本有序"时，再对全体记录进行依次直接插入排序。

## 算法原理
1. 选择一个增量序列t1，t2，...，tk，其中ti>tj，tk=1
2. 按增量序列个数k，对序列进行k趟排序
3. 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m的子序列，分别对各子表进行直接插入排序
4. 仅增量因子为1时，整个序列作为一个表来处理，表长度即为整个序列的长度

## 适用场景
- 中等规模数据的排序
- 数据分布比较随机的情况
- 不要求排序稳定性的场景
- 硬件资源有限，需要就地排序的场景

## 算法特点
### 优点
- 插入排序的改进版，克服了插入排序只能移动相邻记录的缺点
- 较好的时间复杂度，特别是对于中等规模数据
- 就地排序，不需要额外的存储空间

### 缺点
- 不稳定排序
- 增量序列的选择对性能影响较大
- 对于小规模数据，可能不如插入排序

## 算法效率
- 时间复杂度：
  - 平均情况：O(n^1.3)
  - 最坏情况：O(n^2)
  - 最好情况：O(n*log n)
- 空间复杂度：O(1)
- 稳定性：不稳定

## 测试样例说明

### 示例1：随机数据
```cpp
输入：{37, 33, 42, 28, 46, 5, 6, 8, 81, 23, 28, 66, 47, 1, 58, 80, 29, 67, 95, 97}
输出：{1, 5, 6, 8, 23, 28, 28, 29, 33, 37, 42, 46, 47, 58, 66, 67, 80, 81, 95, 97}
```

### 示例2：逆序数据
```cpp
输入：{10, 9, 8, 7, 6, 5, 4, 3, 2, 1}
输出：{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
```

### 示例3：部分有序数据
```cpp
输入：{1, 3, 5, 7, 9, 8, 6, 4, 2, 0}
输出：{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
```

### 示例4：重复元素数据
```cpp
输入：{4, 2, 4, 1, 3, 2, 4, 2, 1, 3}
输出：{1, 1, 2, 2, 2, 3, 3, 4, 4, 4}
```

### 示例5：已排序数据
```cpp
输入：{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
输出：{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
```

## 代码使用说明
1. 代码实现了希尔排序算法
2. 提供了5种不同类型的测试用例：
   - 随机数据
   - 逆序数据
   - 部分有序数据
   - 重复元素数据
   - 已排序数据
3. 每个测试用例都会显示排序前后的数组内容
